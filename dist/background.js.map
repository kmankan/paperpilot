{"version":3,"file":"background.js","mappings":";;;;;;;;;;;AAAA,+BAA+B;;;;;;;;;;AAE/B,2DAA2D;AAC3D,SAAe,UAAU,CAAC,KAAa;;QACrC,IAAI,CAAC;YACH,MAAM,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;YACvD,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,WAAM,CAAC;YACP,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;CAAA;AAED,8CAA8C;AAC9C,SAAe,UAAU;yDAAC,KAAa,EAAE,WAAW,GAAG,EAAE;QACvD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,IAAI,MAAM,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC5B,OAAO,IAAI,CAAC;YACd,CAAC;YACD,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;QAC1D,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CAAA;AAED,MAAM,CAAC,aAAa,CAAC,WAAW,CAAC,WAAW,CAC1C,CAAO,OAAgE,EAAE,EAAE;IACzE,IAAI,OAAO,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;QAC/C,sCAAsC;QACtC,MAAM,OAAO,GAAG,MAAM,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAEhD,IAAI,OAAO,EAAE,CAAC;YACZ,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE;gBACrC,IAAI,EAAE,YAAY;gBAClB,GAAG,EAAE,OAAO,CAAC,GAAG;aACjB,CAAC,CAAC;QACL,CAAC;aAAM,CAAC;YACN,OAAO,CAAC,KAAK,CAAC,iDAAiD,CAAC,CAAC;QACnE,CAAC;IACH,CAAC;AACH,CAAC,GACD,EAAE,GAAG,EAAE,CAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAC,EAAE,CAClC,CAAC;;;;;;;;UExCF;UACA;UACA;UACA;UACA","sources":["webpack://paperpilot/./src/background.ts","webpack://paperpilot/webpack/before-startup","webpack://paperpilot/webpack/startup","webpack://paperpilot/webpack/after-startup"],"sourcesContent":["/// <reference types=\"chrome\"/>\n\n// Helper function to check if a tab is ready for messaging\nasync function isTabReady(tabId: number): Promise<boolean> {\n  try {\n    await chrome.tabs.sendMessage(tabId, { type: 'PING' });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// Helper function to wait for tab to be ready\nasync function waitForTab(tabId: number, maxAttempts = 10): Promise<boolean> {\n  for (let i = 0; i < maxAttempts; i++) {\n    if (await isTabReady(tabId)) {\n      return true;\n    }\n    await new Promise(resolve => setTimeout(resolve, 1000));\n  }\n  return false;\n}\n\nchrome.webNavigation.onCompleted.addListener(\n  async (details: chrome.webNavigation.WebNavigationFramedCallbackDetails) => {\n    if (details.url.toLowerCase().endsWith('.pdf')) {\n      // Wait for content script to be ready\n      const isReady = await waitForTab(details.tabId);\n      \n      if (isReady) {\n        chrome.tabs.sendMessage(details.tabId, {\n          type: 'PDF_LOADED',\n          url: details.url\n        });\n      } else {\n        console.error('Content script not ready after maximum attempts');\n      }\n    }\n  },\n  { url: [{ pathSuffix: '.pdf' }] }\n); ","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/background.ts\"]();\n",""],"names":[],"sourceRoot":""}